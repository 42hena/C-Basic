# 1-1 printf와 scanf를 대신하는 입출력 방식

<h4>문자열 "Hello World"의 출력</h4>
<ul>
    <li>헤더파일 선언문 #include <iostream></li>
    <li>std::cout과 << 연산자를 이용한 출력</li>
    <li><< 연산자를 이용한 개행</li>
</ul>

1-1/HelloWorld.cpp <파일 참고>
<h4>관찰결과 1: 헤더파일 선언문 #include <iostream></h4>
c언어에서 scanf 및 printf를 사용하기 위해서 <stdio.h>를 사용했듯이 c++언어에서 cin, cout 그리고 endl를 사용하기 위해서 <iostream>을 사용한다.
헤더파일 확장자는 C언어와 마찬가지로 .h이다. C++에서 프로그래머가 정의하는 헤더파일의 선언이 아닌, 표준 헤더파일의 선언에서는 확장자를 생략하기로 약속되어 있다.

# 참고
<h4>새로운 라이브러리 등장</h4>
#include <iostream.h>와 같은 헤더파일이 있었으나
1. 과거의 표준 라이브러리와 새로운 표준 라이브러리의 구분
2. 새로운 표준 라이브러리를 사용하는 형태로 소스코드를 쉽게 변경할 수 있게 함
와 같은 이유로 지원하지 않는 추세임.

<h4>관찰결과 2: std::cout과 << 연산자를 이용한 출력</h4>
std::cout<< '출력대상';
출력 대상의 위치에는 무엇이든 올 수 있다.(정수, 실수, 문자열, 변수) 또한 c언어의 printf와 달리 서식문자를 이용해서 지정하지 않아도 적절히 이뤄진다.

<h4>관찰결과 3: << 연산자를 이용한 출력 대상의 연이은 표현과 개행</h4>
<< 도 사실 연산자이고, << 연산자를 이용시에
std::cout << '출력대상' << '출력대상2' << '출력대상3';
과 같이 연속으로 출력 가능하다

<h4>scanf를 대신하는 데이터의 입력</h4>
1-1/SimpleAdder.cpp <파일 참고>
<ul>
    <li>키보드로부터의 데이터 입력에도 헤더파일 선언문 #include <iostream></li>
    <li>키보드로부터의 데이터 입력에는 std::cin과 >> 연산자가 사용된다.</li>
    <li>변수의 선언은 어디서든 가능하다.</li>
</ul>

<h4>관찰결과 1: 데이터의 입력에 사용되는 std::cin과 >> 연산자</h4>
사용방법 -> std::cout<< '변수';
c++에서는 데이터의 입력도 데이터의 출력과 마찬가지로 별도의 포맷 지정이 필요 없다.

<h4>관찰결과2: C++의 지역변수 선언</h4>
c언어에서는 함수를 정의함에 있어서 지역변수의 선언이 제일 먼저 등장해야했지만, c++에서의 지역변수 선언은 함수 내 어디든 가능하다.
1-1/BetweenAdder.cpp <파일 참고>
cin도 마찬가지로 연속적인 데이터의 입력이 가능하다.

<h4>배열 기반의 문자열 입출력</h4>
1-1/StringIO.cpp <파일 참고>

# 1-2 함수 오버로딩(Function Overloading)
<h4>함수 오버로딩의 이해</h4>
c언어에서는 아래와 같이 동일한 이름의 함수가 정의되는 것을 허용하지 않는다
int Myfunc(int num){}
int Myfunc(int a, int b){}
하지만, c++에서는 위와 같은 경우를 허용하는데, 함수호출시 전달되는 인자를 통해서 호출하고자 하는 함수의 구분이 가능하기 때문에 매개변수의 선언형태가 다르다면 동일한 이름의 함수 정의를 허용하고, 함수 오버로딩이라고 한다.

# c언어의 함수 호출과 c++언어의 함수 호출 차이점
c++에서는 함수의 이름, 매개변수의 선언 두 가지 정보를 동시에 활용한다.
MyFunc(30, 40);의 호출문을 보면 두 개의 int형 정수를 인자로 전단받을 수 있는 MyFunc이름의 함수를 찾는다. 
c언어는 함수 이름만 이용해서 호출 대상을 찾는다.
MyFunc 어딨니(C언어)
두 개의 int형 정수를 인자로 전달 받는 MyFunc함수를 찾자(C++언어)

<h4>함수 오버로딩의 예</h4>
함수의 오버로딩이 가능하려면 매개변수의 선언이 달라야한다. 예를 들어서 다음 두 함수는 오버로딩이 가능하다.
int MyFunc(char c){}
int MyFunc(int n){}

이 경우는 매개변수의 개수가 다르므로, 전달되는 인자의 개수를 통해서 호출할 함수의 구분이 가능하기 때문이다.
int MyFunc(int n){}
int MyFunc(int n1, int n2){}
 
정리하면 함수의 오버로딩이 가능하려면 "매개변수의 자료형 또는 개수가 다르다"

<h4>잘못된 오버로딩의 예</h4>
int MyFunc(int n){}
void MyFunc(int n){}
반환형이 다른 경우는 컴파일 오류로 이어진다.
1-2/FunciotnOverloading.cpp <파일 참고>

# 1-3 매개변수의 디폴트 값(Default Value)
c++함수에는 디폴트 값을 설정 가능하다. 디폴트 값이란 기본적으로 설정되어 있는 값을 의미한다.
<h4>매개변수에 설정하는 '디폴트 값'의 의미</h4>
int MyFuncOne(int num = 7)
{
    return num + 1;
}

MyFuncOne()은 
MyFuncOne(7)과 같은 의미

int MyFuncTwo(int num1 = 5, int num2 = 7)
{
    return num1 + num2;
}

MyFuncTwo()은
MyFuncTwo(5, 7)과 같은 의미

즉, 함수호출 시 인자를 전달하지 않으면 지정된 값으로 전달된다는 것으로 간주하겠다라는 뜻이다.
1-3/DefaultValue1.cpp <파일 참고>
매개변수에 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자전달이 가능하다. 그리고 전달되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.

<h4>디폴트 값은 함수의 선언 부분에만 표현하시면 됩니다.</h4>
1-3/DefaultValue2.cpp <파일 참고>

<참고 디폴트 값의 선언이 함수의 선언부분에 위치해야 하는 이유는?>
디폴트 값의 선언이 함수의 선언부분에 위치해야 하는 이유는 조금만 생각해보면 쉽게 알 수 있다. 만약에 디폴트 값의 선언이 함수의 선언부분에 위치하지 않는다면 DefaultValue2.cpp의 6행 7행이 컴파일이 불가능하다.

<h4>부분적 디폴트 값 설정</h4>
반드시 오른쪽 매개변수의 디폴트 값부터 채우는 형태로 정의해야 한다. 즉, 다음의 함수정의는 모두 유효하다.
int YourFUnc(int num1, int num2, int num3){}에서
int YourFUnc(int num1, int num2, int num3=30){} (O)
int YourFUnc(int num1, int num2=20, int num3=30){} (O)
int YourFUnc(int num1=10, int num2=20, int num3=30){} (O)

int YourFUnc(int num1=10, int num2, int num3){} (X)
int YourFUnc(int num1=10, int num2=20, int num3){} (X)

# 이유
오른쪽부터 채울 것을 요구하는 이유는 무엇일까?
함수에 전달되는 인자가 왼쪽에서부터 오른쪽으로 채워지기 때문입니다.
YourFunc(10, 20) -> YourFunc(10, 20, 30)?

# 1-4 인라인 함수
in + line(내부 + 프로그램 코드라인) = 프로그램 코드라인 안으로 들어가 버린 함수

<h4>매크로 함수의 장점</h4>
일반적인 함수에 비해서 실행속도의 이점이 있다.

<h4>매크로 함수의 단점</h4>
정의하기가 어렵다. 복잡한 함수를 매크로의 형태로 정의하는 데 한계가 있다.

#define SQUARE(X) ((X)*(X))
전처리 과정을 거치면 SQUARE(5)는 ((5)*(5))로 변한다.
함수의 몸체부분이 함수의 호출문을 대체했을 때 함수가 인라인화 되었다라 표현한다.

<h4>C++ 기반의 인라인 함수 정의</h4>
1-4/InlineFunc.cpp <파일 참고>


함수의 인라인화는 전처리기에 의해서 처리되지만, 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해서 처리된다. 컴파일러는 함수의 인라인화가 오히려 성능에 해가 된다고 판단할 경우 키워드를 무시해버리기도 한다. 또한 컴파일러는 필요한 경우 일부 함수를 임의로 인라인 처리하기도 한다.

<h4>매크로 함수에는 있지만, 인라인 함수에는 없는 장점</h4>
#define SQUARE(X) ((X)*(X)) 는 데이터 손실이 이뤄지지 않는다.
inline int SQUARE(int x) {return x*x;}는 int기반이므로 3.15출력시 손실

<해결방법>
- 함수 오버로딩(여러 개의 함수를 추가로 정의해야하는 단점이 있음)
- 템플릿 이용


# 1-5 이름 공간
<h4>이름공간의 등장 배경</h4>
프로그램이 대형화되어 이름의 충돌문제가 생겼다. 3개의 회사가 프로젝트하는데 함수이름이 같아 충돌이 나는 경우가 있다. 프로젝트 진행 전에 함수 및 변수의 이름을 모두 정해서 이름 충돌이 발생하지 않게 하는 것도 한가지의 방법이지만, c++ 표준에서 이름공간이라는 문법을 정의해서 해결 가능

<h4>이름 공간의 기본원리</h4>
201호에 사는 철수와 202호에 사는 철수

namespace 이름
{
    //이름 공간 내부
}

1-5/NameSp1.cpp <파일 참고>
::을 가리켜 범위지정 연산자라 하며 이름공간을 지정할 때 사용하는 연산자이다.

<h4>이름공간 기반의 함수 선언과 정의의 구분</h4>
함수는 선언과 정의를 분리하는 것이 일반적이다. 보통 함수의 선언은 헤더파일에 지정하고, 함수의 정의는 소스파일에 저장한다.
1-5/NameSp2.cpp <파일 참고>

동일한 이름공간에 정의된 함수를 호출할 떄는 이름공간을 명시할 필요가 없다.
1-5/NameSp3.cpp <파일 참고>

<h4>이름공간의 중첩</h4>
이름공간은 다른 이름 공간 안에 삽입될 수 있다.

<h4>std::cout, std::cin, std::endl</h4>
아무것도 모른채 std::를 사용해왔지만, std라는 이름 공간에 선언된 것이라는 것을 알 수 있다.

<h4>Using을 이용한 이름공간의 명시</h4>
1-5/UsingDcl1.cpp <파일 참고>
using Hybrid::HybFunc;
이름공간 Hybrid에서 HybFunc를 찾으라는 선언이고, HybFunc는 변수의 이름 또는 함수의 이름이 된다. 함수 전체에 영향을 미치고 싶으면 함수 밖에 써야한다.(지역변수 같은 개념처럼 됨)


1-5/UsingDcl2.cpp <파일 참고>
이름공간 std에 선언된 모든것에 대해 이름공간 지정의 생략을 명령은
using namespace std;

하지만 이렇게 선언을 해버리면 이름 충돌이 발생할 확률이 높아지므로, 혼용해야함(하지만 안 쓸 예정임)

<h4>이름공간의 별칭 지정</h4>
namespace ABC = AAA:BBB:CCC;와 같이 지정가능

<h4>범위지정 연산자(Scope Resolution Operator)의 또 다른 기능</h4>
지역변수의 이름이 전역변수의 이름과 같을 경우, 전역변수는 지역변수에 의해 가려지는데 범위 연산자로 계산이 가능하다.